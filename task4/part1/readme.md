# Завдання 1 до теми №4 "Режими роботи шифрів та особливості реалізації"

Для виконання завдання було підготовлено файл з кодом на мові програмування Python 3, з методами encrypt, receive та get_flag, що реалізують роботу з відповідними API-ендпоінтами Cryptohack. 
Відповідно до схеми режиму CBC, при шифруванні шифротекст блоку А ксориться з плейнтекстом блоку Б. Сам криптопримітив шифрування можна розглядати як деяку функцію:
``` 
e(key, value)
```
Дана функція є детермінованою, тобто при однакових вхідних значеннях, завжди буде однакове вихідне. При розшифруванні застосовується зворотня функція: 
``` 
d(key, value)
```
При дешифруванні блоків у режимі CBC, спочатку виконується функція d, а потім виконується XOR із попереднім блоком. 

У нас є можливість шифрувати довільні тексти та заставляти сервер розшифровувати їх. Отже, можемо реалізувати криптоаналіз на основі підібраного шифротексту.

Оскільки невідомим для нас є IV, враховуєчи конструктивні особливості режиму CBC, ми можемо його відновити такою послідовністю дій:
 1. Згенерувати довільний шифротекст (достатньо 1го шифрованого блоку, для того щоб виконався XOR шифротексту з IV);
 2. Додати до отриманого шифротексту ще один повний блок попереду (таким чином 1й блок шифротексту при розшифруванні фактично виступатиме в ролі IV для 2го блоку шифротексту)
 3. Виконати брутфорс 1го блоку шифротексту (задачу спрощує те, що XOR виконується в потоковому режимі, тобто нам не треба брутити весь блок цілісно, а можна це робити по 1 біту/нібблу/байту, причому в нас є критерій успіху - наш початковий шифротекст, що додатково зменшує фактичну множину перебору)
 4. Задача буде вважатись виконаною коли 2й блок розшифрованого тексту буде ідентичний до 1го блоку початкового плейнтексту (тоді підібраний блок шифротексту фактично буде ідентичний до початкового IV) 

Описані кроки було реалізовано у вигляді коду на мові Python.
Фінальний код представлено у файлі [task4_1_lazy_cbc.py](task4_1_lazy_cbc.py)

Щоб завжди провокувати помилку у методі receive, до шифротексту в кінці завжди додавався блок нулів (вони не могли розшифруватись в ASCII-символи й метод завжди повертав помилку "Invalid plaintext" із розшифрованим текстом, що і було потрібно).

## Результат
Спочатку в ручному режимі було зашифровано блоки нулів, з яких отримано блоки шифротексту:

```
 ffd8c93b9c3a8fb8d325f520549a551c d4d7c7f76d6541c5515721021fd7da75 a5752598167012c086c1ec13acbfc007
```

Цінність становить лише 1й із них.

Далі було реалізовано метод ``find_iv``, який брутив 1й блок шифротексту по одному нібблу. За результатами його роботи було отримано послідовність, яка ймовірно і є потрібним вектором:

```
 4d66727acc9652f2abc06f1718c76464
```

За допомогою методу ``get_flag``, було отримано відповідь:

`` 
    {'plaintext': '63727970746f7b35306d335f703330706c335f64306e375f3768316e6b5f49565f31355f316d70307237346e375f3f7d'}
``

За допомогою вебутиліти CyberChef, дана послідовність була конвертована у текстове значення:

`` 
    crypto{50m3_p30pl3_d0n7_7h1nk_IV_15_1mp0r74n7_?}
``
